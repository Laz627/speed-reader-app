<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#0a0a0a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="description" content="RSVP Speed Reader for EPUB books">
  
  <title>Speed Reader</title>
  
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  
  <!-- Preload fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Montserrat:wght@400;500&display=swap" rel="stylesheet">
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body, #root {
      height: 100%;
      overflow: hidden;
    }
    
    body {
      font-family: 'Inter', system-ui, sans-serif;
      -webkit-font-smoothing: antialiased;
      background-color: #0a0a0a;
    }
    
    /* Range input styling */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #ef4444;
      cursor: pointer;
      margin-top: -7px;
    }
    
    input[type="range"]::-webkit-slider-runnable-track {
      height: 4px;
      border-radius: 2px;
    }
    
    /* Hide scrollbar but allow scroll */
    .hide-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .hide-scrollbar::-webkit-scrollbar {
      display: none;
    }
    
    /* Select styling */
    select {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 4px center;
      padding-right: 20px;
    }
    
    /* Chapter splash animation */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    
    .chapter-splash {
      animation: fadeInUp 0.5s ease-out;
    }
    
    .chapter-splash.fading {
      animation: fadeOut 0.5s ease-out forwards;
    }
    
    /* Dialogue indicator pulse */
    @keyframes subtlePulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 0.9; }
    }
    
    /* Navigation feedback animation */
    @keyframes navFeedbackPop {
      0% { 
        opacity: 0; 
        transform: translateX(-50%) scale(0.5);
      }
      20% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1.1);
      }
      100% { 
        opacity: 1; 
        transform: translateX(-50%) scale(1);
      }
    }
    
    @keyframes navFeedbackSlideLeft {
      0% { transform: translateX(-50%) translateX(20px); opacity: 0; }
      100% { transform: translateX(-50%) translateX(0); opacity: 1; }
    }
    
    @keyframes navFeedbackSlideRight {
      0% { transform: translateX(-50%) translateX(-20px); opacity: 0; }
      100% { transform: translateX(-50%) translateX(0); opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="root"><div style="display:flex;align-items:center;justify-content:center;min-height:100vh;color:#666;">Loading...</div></div>
  <noscript><div style="padding:2rem;text-align:center;color:#ef4444;">JavaScript is required to run this app.</div></noscript>
  
  <!-- React -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- JSZip for EPUB parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  
  <script>
    // Check dependencies loaded
    if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
      document.getElementById('root').innerHTML = '<div style="color: #ef4444; padding: 2rem; text-align: center;">Failed to load React. Check your internet connection.</div>';
      throw new Error('React not loaded');
    }
    if (typeof JSZip === 'undefined') {
      document.getElementById('root').innerHTML = '<div style="color: #ef4444; padding: 2rem; text-align: center;">Failed to load JSZip. Check your internet connection.</div>';
      throw new Error('JSZip not loaded');
    }

    // ============================================================
    // CONSTANTS & SPECIAL MARKERS
    // ============================================================
    
    // Special marker for paragraph breaks (pilcrow symbol)
    const PARAGRAPH_MARKER = '\u00B6PARA\u00B6';
    
    // Punctuation patterns for stripping from display
    const LEADING_PUNCT = /^["'"'Â«Â¿Â¡([{]+/;
    const TRAILING_PUNCT = /[""''Â»)\]}.!?,;:â€”â€“-]+$/;
    
    // Quote characters for tracking dialogue state
    const OPEN_QUOTES = ['"', "'", "\u201C", "\u2018", 'Â«', 'Â¿', 'Â¡'];
    const CLOSE_QUOTES = ['"', "'", "\u201D", "\u2019", 'Â»'];
    
    // ============================================================
    // ORP (Optimal Recognition Point) Logic
    // ============================================================
    
    const ORP_TABLE = {
      1: 0, 2: 0, 3: 1, 4: 1, 5: 1, 6: 2, 7: 2, 8: 2, 9: 3, 10: 3, 11: 3, 12: 4, 13: 4,
    };

    function getORPIndex(word) {
      // Strip punctuation for ORP calculation
      const letters = word.replace(/[^a-zA-Z]/g, '');
      const len = letters.length;
      if (len === 0) return 0;
      if (len <= 13) return ORP_TABLE[len];
      return Math.floor(len * 0.3);
    }

    function getORPPositionInWord(word) {
      const orpIndex = getORPIndex(word);
      let letterCount = 0;
      
      for (let i = 0; i < word.length; i++) {
        if (/[a-zA-Z]/.test(word[i])) {
          if (letterCount === orpIndex) return i;
          letterCount++;
        }
      }
      return 0;
    }

    // ============================================================
    // Word Processing for Display
    // Separates leading/trailing punctuation from core word
    // ============================================================
    
    function processWordForDisplay(word) {
      // Handle paragraph markers - not displayed
      if (word === PARAGRAPH_MARKER) {
        return { leadingPunct: '', coreWord: '', trailingPunct: '', isParagraphBreak: true };
      }
      
      let leadingPunct = '';
      let trailingPunct = '';
      let coreWord = word;
      
      // Extract leading punctuation
      const leadingMatch = coreWord.match(LEADING_PUNCT);
      if (leadingMatch) {
        leadingPunct = leadingMatch[0];
        coreWord = coreWord.slice(leadingPunct.length);
      }
      
      // Extract trailing punctuation
      const trailingMatch = coreWord.match(TRAILING_PUNCT);
      if (trailingMatch) {
        trailingPunct = trailingMatch[0];
        coreWord = coreWord.slice(0, -trailingPunct.length);
      }
      
      // If everything got stripped, restore the original
      if (!coreWord && word) {
        coreWord = word;
        leadingPunct = '';
        trailingPunct = '';
      }
      
      return { leadingPunct, coreWord, trailingPunct, isParagraphBreak: false };
    }
    
    // ============================================================
    // Dialogue State Tracking
    // Tracks whether we're inside quotes across words
    // ============================================================
    
    function updateDialogueState(word, currentlyInDialogue) {
      let inDialogue = currentlyInDialogue;
      
      for (const char of word) {
        if (OPEN_QUOTES.includes(char) && !inDialogue) {
          inDialogue = true;
        } else if (CLOSE_QUOTES.includes(char) && inDialogue) {
          // Check if it's a closing quote (basic heuristic: after letters)
          const idx = word.indexOf(char);
          if (idx > 0 || currentlyInDialogue) {
            inDialogue = false;
          }
        }
      }
      
      return inDialogue;
    }

    // ============================================================
    // EPUB Parser
    // ============================================================

    async function parseEPUB(file) {
      const zip = await JSZip.loadAsync(file);
      
      const containerXml = await zip.file('META-INF/container.xml')?.async('string');
      if (!containerXml) throw new Error('Invalid EPUB: missing container.xml');
      
      const opfPathMatch = containerXml.match(/full-path="([^"]+)"/);
      if (!opfPathMatch) throw new Error('Invalid EPUB: cannot find OPF path');
      
      const opfPath = opfPathMatch[1];
      const opfDir = opfPath.substring(0, opfPath.lastIndexOf('/') + 1);
      
      const opfContent = await zip.file(opfPath)?.async('string');
      if (!opfContent) throw new Error('Invalid EPUB: missing OPF file');
      
      const titleMatch = opfContent.match(/<dc:title[^>]*>([^<]+)<\/dc:title>/i);
      const title = titleMatch ? titleMatch[1].trim() : file.name.replace('.epub', '');
      
      const spineMatches = [...opfContent.matchAll(/<itemref[^>]+idref="([^"]+)"[^>]*>/g)];
      const spineIds = spineMatches.map(m => m[1]);
      
      const manifestItems = {};
      const itemMatches = [...opfContent.matchAll(/<item[^>]+id="([^"]+)"[^>]+href="([^"]+)"[^>]*>/g)];
      itemMatches.forEach(m => { manifestItems[m[1]] = m[2]; });
      
      const itemMatches2 = [...opfContent.matchAll(/<item[^>]+href="([^"]+)"[^>]+id="([^"]+)"[^>]*>/g)];
      itemMatches2.forEach(m => { manifestItems[m[2]] = m[1]; });
      
      const chapters = [];
      
      for (const spineId of spineIds) {
        const href = manifestItems[spineId];
        if (!href) continue;
        
        // Handle URL-encoded paths
        const decodedHref = decodeURIComponent(href);
        const fullPath = opfDir + decodedHref;
        
        let content = await zip.file(fullPath)?.async('string');
        if (!content) {
          // Try without decoding
          content = await zip.file(opfDir + href)?.async('string');
        }
        if (!content) continue;
        
        const text = extractTextFromHTML(content);
        if (text.trim().length < 50) continue;
        
        const h1Match = content.match(/<h1[^>]*>([^<]+)<\/h1>/i);
        const h2Match = content.match(/<h2[^>]*>([^<]+)<\/h2>/i);
        const titleTagMatch = content.match(/<title[^>]*>([^<]+)<\/title>/i);
        const chapterTitle = h1Match?.[1]?.trim() || h2Match?.[1]?.trim() || titleTagMatch?.[1]?.trim() || `Chapter ${chapters.length + 1}`;
        
        chapters.push({
          id: spineId,
          title: chapterTitle.substring(0, 50),
          text: text.trim(),
        });
      }
      
      if (chapters.length === 0) {
        throw new Error('Could not extract any chapters from EPUB');
      }
      
      return { title, chapters };
    }

    function extractTextFromHTML(html) {
      let text = html.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
      text = text.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
      
      // Mark paragraph breaks with special handling
      // Replace closing paragraph/div tags with double newlines
      text = text.replace(/<\/(p|div)>/gi, '\n\n');
      text = text.replace(/<\/(h[1-6]|li|tr)>/gi, '\n');
      text = text.replace(/<br[^>]*>/gi, '\n');
      text = text.replace(/<[^>]+>/g, ' ');
      
      // HTML entities
      text = text.replace(/&nbsp;/g, ' ');
      text = text.replace(/&amp;/g, '&');
      text = text.replace(/&lt;/g, '<');
      text = text.replace(/&gt;/g, '>');
      text = text.replace(/&quot;/g, '"');
      text = text.replace(/&rsquo;/g, "'");
      text = text.replace(/&lsquo;/g, "'");
      text = text.replace(/&rdquo;/g, '"');
      text = text.replace(/&ldquo;/g, '"');
      text = text.replace(/&mdash;/g, 'â€”');
      text = text.replace(/&ndash;/g, 'â€“');
      text = text.replace(/&hellip;/g, 'â€¦');
      text = text.replace(/&#(\d+);/g, (_, code) => String.fromCharCode(code));
      
      // Normalize spaces
      text = text.replace(/[ \t]+/g, ' ');
      
      // Preserve paragraph breaks by replacing double+ newlines with marker
      // This happens BEFORE we split into words
      text = text.replace(/\n\s*\n\s*/g, ` ${PARAGRAPH_MARKER} `);
      
      // Single newlines become spaces
      text = text.replace(/\n/g, ' ');
      
      return text.trim();
    }

    // ============================================================
    // Progress Storage
    // ============================================================

    function getStorageKey(bookTitle) {
      return `speedreader_${bookTitle.replace(/[^a-zA-Z0-9]/g, '_')}`;
    }

    function saveProgress(bookTitle, chapterIndex, wordIndex) {
      try {
        localStorage.setItem(getStorageKey(bookTitle), JSON.stringify({
          chapterIndex,
          wordIndex,
          timestamp: Date.now(),
        }));
      } catch (e) {}
    }

    function loadProgress(bookTitle) {
      try {
        const data = localStorage.getItem(getStorageKey(bookTitle));
        if (data) return JSON.parse(data);
      } catch (e) {}
      return null;
    }

    // ============================================================
    // Main Component
    // ============================================================

    const { useState, useEffect, useCallback, useRef } = React;

    function SpeedReader() {
      // Book state
      const [book, setBook] = useState(null);
      const [chapterIndex, setChapterIndex] = useState(0);
      const [isDragging, setIsDragging] = useState(false);
      const [loadError, setLoadError] = useState(null);
      const [isLoading, setIsLoading] = useState(false);
      
      // Reading state
      const [words, setWords] = useState([]);
      const [sentences, setSentences] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [isPlaying, setIsPlaying] = useState(false);
      const [wpm, setWpm] = useState(300);
      const [darkMode, setDarkMode] = useState(true);
      const [pausesEnabled, setPausesEnabled] = useState(true);
      const [showTextInput, setShowTextInput] = useState(false);
      const [inputText, setInputText] = useState('');
      
      // NEW: Chapter splash state
      const [showChapterSplash, setShowChapterSplash] = useState(false);
      const [splashFading, setSplashFading] = useState(false);
      const [pendingPlay, setPendingPlay] = useState(false);
      
      // NEW: Dialogue tracking state
      const [inDialogue, setInDialogue] = useState(false);
      
      // NEW: Focus mode state (hides all UI except word)
      const [focusMode, setFocusMode] = useState(false);
      
      // NEW: Navigation feedback state (shows +1, -2, etc on nav)
      const [navFeedback, setNavFeedback] = useState(null); // { direction: 'forward'|'back', count: 1 }
      const navFeedbackTimeoutRef = useRef(null);
      const navCountRef = useRef(0);
      const navDirectionRef = useRef(null);
      
      const intervalRef = useRef(null);
      const fileInputRef = useRef(null);
      const saveIntervalRef = useRef(null);
      const splashTimeoutRef = useRef(null);

      const demoText = `Welcome to Speed Reader. Drop an EPUB file anywhere on this screen to begin reading, or tap the Open button below.

The app will parse your book into chapters and let you navigate between them using the dropdown menu.

Use the Play button to start reading at your chosen speed. The red letter marks the optimal recognition point for each word, helping your brain process text more efficiently.

Your progress is automatically saved, so you can close the app and pick up right where you left off.

"This is example dialogue," she said, "to demonstrate how quotes are now handled more smoothly."

Adjust your reading speed with the WPM slider. Most people start around 300 words per minute and gradually increase with practice. Happy reading!`;

      // ============================================================
      // Parse chapter text into words with paragraph markers
      // ============================================================
      useEffect(() => {
        const text = book ? book.chapters[chapterIndex]?.text : demoText;
        if (!text) return;
        
        // Split by whitespace, keeping paragraph markers as separate tokens
        const parsed = text.trim().split(/\s+/).filter(w => w.length > 0);
        setWords(parsed);
        
        // Build sentence indices (excluding paragraph markers)
        const sentenceIndices = [];
        let sentenceStart = 0;
        
        parsed.forEach((word, idx) => {
          if (word === PARAGRAPH_MARKER) return; // Skip markers for sentence calculation
          if (/[.!?]$/.test(word)) {
            sentenceIndices.push({ start: sentenceStart, end: idx });
            sentenceStart = idx + 1;
          }
        });
        
        if (sentenceStart < parsed.length) {
          sentenceIndices.push({ start: sentenceStart, end: parsed.length - 1 });
        }
        
        setSentences(sentenceIndices);
        
        // Reset dialogue state for new chapter
        setInDialogue(false);
      }, [book, chapterIndex]);

      // ============================================================
      // Load saved progress
      // ============================================================
      useEffect(() => {
        if (book) {
          const saved = loadProgress(book.title);
          if (saved) {
            setChapterIndex(saved.chapterIndex);
            setCurrentIndex(saved.wordIndex);
          } else {
            setChapterIndex(0);
            setCurrentIndex(0);
          }
        }
      }, [book?.title]);

      // Save progress while playing
      useEffect(() => {
        if (book && isPlaying) {
          saveIntervalRef.current = setInterval(() => {
            saveProgress(book.title, chapterIndex, currentIndex);
          }, 5000);
          return () => clearInterval(saveIntervalRef.current);
        }
      }, [book, isPlaying, chapterIndex, currentIndex]);

      // Save on pause
      useEffect(() => {
        if (book && !isPlaying) {
          saveProgress(book.title, chapterIndex, currentIndex);
        }
      }, [book, isPlaying, chapterIndex, currentIndex]);

      // ============================================================
      // Chapter splash screen logic
      // Shows chapter title for 3 seconds when chapter changes
      // ============================================================
      const triggerChapterSplash = useCallback((chapterIdx, shouldAutoPlay = false) => {
        // Clear any existing splash timeout
        if (splashTimeoutRef.current) {
          clearTimeout(splashTimeoutRef.current);
        }
        
        setShowChapterSplash(true);
        setSplashFading(false);
        setPendingPlay(shouldAutoPlay);
        
        // Start fade out after 2.5 seconds
        splashTimeoutRef.current = setTimeout(() => {
          setSplashFading(true);
          
          // Hide completely after fade
          setTimeout(() => {
            setShowChapterSplash(false);
            setSplashFading(false);
            
            // Auto-play if this was triggered by chapter advance
            if (shouldAutoPlay) {
              setIsPlaying(true);
            }
          }, 500);
        }, 2500);
      }, []);

      // Cleanup splash timeout on unmount
      useEffect(() => {
        return () => {
          if (splashTimeoutRef.current) {
            clearTimeout(splashTimeoutRef.current);
          }
        };
      }, []);

      // ============================================================
      // Sentence navigation helpers
      // ============================================================
      const getCurrentSentence = useCallback(() => {
        for (let i = 0; i < sentences.length; i++) {
          if (currentIndex >= sentences[i].start && currentIndex <= sentences[i].end) {
            return i;
          }
        }
        return 0;
      }, [currentIndex, sentences]);

      // ============================================================
      // Delay calculation with extended punctuation rules
      // ============================================================
      const getDelay = useCallback((word) => {
        const baseDelay = 60000 / wpm;
        if (!pausesEnabled) return baseDelay;
        
        // Paragraph break = long pause (2.5 seconds)
        if (word === PARAGRAPH_MARKER) {
          return 2500;
        }
        
        // Em-dash (â€”) = 1.3x delay
        if (word.includes('â€”')) {
          return baseDelay * 1.3;
        }
        
        // Ellipsis (...) = 1.8x delay
        if (word.includes('...') || word.includes('â€¦')) {
          return baseDelay * 1.8;
        }
        
        // Sentence-ending punctuation = 2.2x delay
        if (/[.!?]["'"']?$/.test(word)) {
          return baseDelay * 2.2;
        }
        
        // Comma, semicolon, colon = 1.4x delay
        if (/[,;:]$/.test(word)) {
          return baseDelay * 1.4;
        }
        
        // Opening quote at start of word = 1.2x delay (slight pause before dialogue)
        if (LEADING_PUNCT.test(word) && /^["'"'Â«]/.test(word)) {
          return baseDelay * 1.2;
        }
        
        // Long words get slight delay
        const len = word.replace(/[^a-zA-Z]/g, '').length;
        if (len > 10) return baseDelay * 1.15;
        if (len > 7) return baseDelay * 1.08;
        
        return baseDelay;
      }, [wpm, pausesEnabled]);

      // ============================================================
      // Playback loop
      // ============================================================
      useEffect(() => {
        if (isPlaying && words.length > 0 && !showChapterSplash) {
          const currentWord = words[currentIndex] || '';
          const delay = getDelay(currentWord);
          
          intervalRef.current = setTimeout(() => {
            // Update dialogue state
            if (currentWord !== PARAGRAPH_MARKER) {
              setInDialogue(prev => updateDialogueState(currentWord, prev));
            }
            
            setCurrentIndex(prev => {
              if (prev >= words.length - 1) {
                // End of chapter - advance to next if available
                if (book && chapterIndex < book.chapters.length - 1) {
                  const nextChapter = chapterIndex + 1;
                  setChapterIndex(nextChapter);
                  setIsPlaying(false); // Pause for splash
                  triggerChapterSplash(nextChapter, true); // Will auto-play after splash
                  return 0;
                }
                setIsPlaying(false);
                return prev;
              }
              return prev + 1;
            });
          }, delay);
        }
        
        return () => {
          if (intervalRef.current) clearTimeout(intervalRef.current);
        };
      }, [isPlaying, currentIndex, words, getDelay, book, chapterIndex, showChapterSplash, triggerChapterSplash]);

      // Reset index when chapter changes (manual change)
      useEffect(() => {
        if (book) {
          const saved = loadProgress(book.title);
          if (!saved || saved.chapterIndex !== chapterIndex) {
            setCurrentIndex(0);
            setInDialogue(false);
          }
        }
      }, [chapterIndex]);

      // ============================================================
      // Event handlers
      // ============================================================
      const handleDragOver = (e) => {
        e.preventDefault();
        setIsDragging(true);
      };

      const handleDragLeave = (e) => {
        e.preventDefault();
        setIsDragging(false);
      };

      const handleDrop = async (e) => {
        e.preventDefault();
        setIsDragging(false);
        const file = e.dataTransfer.files[0];
        if (file) await loadFile(file);
      };

      const handleFileSelect = async (e) => {
        const file = e.target.files?.[0];
        if (file) await loadFile(file);
      };

      const loadFile = async (file) => {
        if (!file.name.toLowerCase().endsWith('.epub')) {
          setLoadError('Please select an EPUB file');
          return;
        }
        
        setIsLoading(true);
        setLoadError(null);
        setIsPlaying(false);
        
        try {
          const parsed = await parseEPUB(file);
          setBook(parsed);
          setCurrentIndex(0);
          setInDialogue(false);
          
          // Show chapter splash for first chapter
          triggerChapterSplash(0, false);
        } catch (err) {
          console.error('EPUB parse error:', err);
          setLoadError(err.message || 'Failed to parse EPUB');
        } finally {
          setIsLoading(false);
        }
      };

      const handlePlayPause = () => {
        // Don't allow play during splash
        if (showChapterSplash) return;
        
        if (currentIndex >= words.length - 1 && !isPlaying) {
          setCurrentIndex(0);
          setInDialogue(false);
        }
        setIsPlaying(!isPlaying);
      };

      const handleReset = () => {
        setIsPlaying(false);
        setCurrentIndex(0);
        setInDialogue(false);
      };

      // Show navigation feedback with stacking count
      const showNavFeedback = useCallback((direction) => {
        // Clear existing timeout
        if (navFeedbackTimeoutRef.current) {
          clearTimeout(navFeedbackTimeoutRef.current);
        }
        
        // If same direction, increment count; otherwise reset
        if (navDirectionRef.current === direction) {
          navCountRef.current += 1;
        } else {
          navCountRef.current = 1;
          navDirectionRef.current = direction;
        }
        
        setNavFeedback({ direction, count: navCountRef.current });
        
        // Clear after 800ms of no activity
        navFeedbackTimeoutRef.current = setTimeout(() => {
          setNavFeedback(null);
          navCountRef.current = 0;
          navDirectionRef.current = null;
        }, 800);
      }, []);

      const handleBackSentence = useCallback(() => {
        const currentSentenceIdx = getCurrentSentence();
        const currentSentence = sentences[currentSentenceIdx];
        
        if (currentIndex > currentSentence?.start) {
          setCurrentIndex(currentSentence.start);
        } else if (currentSentenceIdx > 0) {
          setCurrentIndex(sentences[currentSentenceIdx - 1].start);
        }
        
        // Reset dialogue state when navigating (simplified approach)
        setInDialogue(false);
        showNavFeedback('back');
      }, [getCurrentSentence, sentences, currentIndex, showNavFeedback]);

      const handleForwardSentence = useCallback(() => {
        const currentSentenceIdx = getCurrentSentence();
        
        if (currentSentenceIdx < sentences.length - 1) {
          setCurrentIndex(sentences[currentSentenceIdx + 1].start);
          showNavFeedback('forward');
        }
      }, [getCurrentSentence, sentences, showNavFeedback]);

      const handleChapterChange = (newIndex) => {
        setIsPlaying(false);
        setChapterIndex(newIndex);
        setCurrentIndex(0);
        setInDialogue(false);
        triggerChapterSplash(newIndex, false);
      };

      const handleSetText = () => {
        if (showTextInput && inputText.trim()) {
          setBook({
            title: 'Pasted Text',
            chapters: [{ id: 'manual', title: 'Text', text: inputText.trim() }],
          });
          setChapterIndex(0);
          setCurrentIndex(0);
          setInDialogue(false);
          setShowTextInput(false);
          setInputText('');
        } else {
          setShowTextInput(!showTextInput);
          setInputText(book?.chapters[chapterIndex]?.text || demoText);
        }
      };

      const handleCloseBook = () => {
        setBook(null);
        setChapterIndex(0);
        setCurrentIndex(0);
        setIsPlaying(false);
        setInDialogue(false);
        setShowChapterSplash(false);
      };

      // ============================================================
      // Refs for keyboard handler (to avoid stale closures)
      // ============================================================
      const stateRef = useRef({});
      stateRef.current = {
        book,
        chapterIndex,
        currentIndex,
        words,
        sentences,
        isPlaying,
        showChapterSplash,
        showTextInput,
        loadError,
        getCurrentSentence,
        triggerChapterSplash,
        showNavFeedback,
      };

      // ============================================================
      // Keyboard shortcuts
      // Space = play/pause, Left/Right = sentence nav, Up/Down = chapter
      // F = toggle focus mode, Escape = exit focus mode
      // ============================================================
      useEffect(() => {
        const handleKeyDown = (e) => {
          // Ignore if typing in textarea
          if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;
          
          const state = stateRef.current;
          
          switch (e.code) {
            case 'Space':
              e.preventDefault();
              if (!state.showChapterSplash) {
                if (state.currentIndex >= state.words.length - 1) {
                  setCurrentIndex(0);
                  setInDialogue(false);
                }
                setIsPlaying(prev => !prev);
              }
              break;
            case 'ArrowLeft':
              e.preventDefault();
              // Go back a sentence
              {
                const currentSentenceIdx = state.getCurrentSentence();
                const currentSentence = state.sentences[currentSentenceIdx];
                if (state.currentIndex > currentSentence?.start) {
                  setCurrentIndex(currentSentence.start);
                } else if (currentSentenceIdx > 0) {
                  setCurrentIndex(state.sentences[currentSentenceIdx - 1].start);
                }
                setInDialogue(false);
                state.showNavFeedback('back');
              }
              break;
            case 'ArrowRight':
              e.preventDefault();
              // Go forward a sentence
              {
                const currentSentenceIdx = state.getCurrentSentence();
                if (currentSentenceIdx < state.sentences.length - 1) {
                  setCurrentIndex(state.sentences[currentSentenceIdx + 1].start);
                  state.showNavFeedback('forward');
                }
              }
              break;
            case 'ArrowUp':
              e.preventDefault();
              if (state.book && state.chapterIndex > 0) {
                const newChapter = state.chapterIndex - 1;
                setIsPlaying(false);
                setChapterIndex(newChapter);
                setCurrentIndex(0);
                setInDialogue(false);
                state.triggerChapterSplash(newChapter, false);
              }
              break;
            case 'ArrowDown':
              e.preventDefault();
              if (state.book && state.chapterIndex < state.book.chapters.length - 1) {
                const newChapter = state.chapterIndex + 1;
                setIsPlaying(false);
                setChapterIndex(newChapter);
                setCurrentIndex(0);
                setInDialogue(false);
                state.triggerChapterSplash(newChapter, false);
              }
              break;
            case 'KeyF':
              e.preventDefault();
              setFocusMode(prev => !prev);
              break;
            case 'Escape':
              e.preventDefault();
              setFocusMode(false);
              break;
          }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []); // Empty deps - handler uses ref for current values

      // ============================================================
      // Tap zone handler for mobile
      // Left third = back, right third = forward, center = play/pause
      // ============================================================
      const handleTapZone = useCallback((e) => {
        // Only handle taps on the display area, not buttons
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT' || 
            e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        const state = stateRef.current;
        
        // Don't handle during splash or text input
        if (state.showChapterSplash || state.showTextInput || state.loadError) return;
        
        // Get click/touch position - handle both mouse and touch events
        const rect = e.currentTarget.getBoundingClientRect();
        let clientX;
        if (e.touches && e.touches.length > 0) {
          clientX = e.touches[0].clientX;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
          clientX = e.changedTouches[0].clientX;
        } else {
          clientX = e.clientX;
        }
        
        const x = clientX - rect.left;
        const width = rect.width;
        const zone = x / width;
        
        if (zone < 0.33) {
          // Left third - go back
          const currentSentenceIdx = state.getCurrentSentence();
          const currentSentence = state.sentences[currentSentenceIdx];
          if (state.currentIndex > currentSentence?.start) {
            setCurrentIndex(currentSentence.start);
          } else if (currentSentenceIdx > 0) {
            setCurrentIndex(state.sentences[currentSentenceIdx - 1].start);
          }
          setInDialogue(false);
          state.showNavFeedback('back');
        } else if (zone > 0.67) {
          // Right third - go forward
          const currentSentenceIdx = state.getCurrentSentence();
          if (currentSentenceIdx < state.sentences.length - 1) {
            setCurrentIndex(state.sentences[currentSentenceIdx + 1].start);
            state.showNavFeedback('forward');
          }
        } else {
          // Center - play/pause
          if (!state.showChapterSplash) {
            if (state.currentIndex >= state.words.length - 1) {
              setCurrentIndex(0);
              setInDialogue(false);
            }
            setIsPlaying(prev => !prev);
          }
        }
      }, []);

      // ============================================================
      // Word rendering with punctuation separation
      // ============================================================
      const renderWord = () => {
        const word = words[currentIndex] || '';
        if (!word) return React.createElement('span', { style: { opacity: 0.3 } }, 'â€”');
        
        // Handle paragraph markers - show a subtle indicator
        if (word === PARAGRAPH_MARKER) {
          return React.createElement('span', {
            style: {
              opacity: 0.2,
              fontSize: 'clamp(1.5rem, 8vw, 3rem)',
            }
          }, 'Â¶');
        }
        
        // Process word to separate punctuation
        const { leadingPunct, coreWord, trailingPunct } = processWordForDisplay(word);
        
        // Calculate ORP position on the CORE word only
        const orpPos = getORPPositionInWord(coreWord);
        
        // Style for dimmed punctuation
        const punctStyle = {
          color: darkMode ? 'rgba(255,255,255,0.35)' : 'rgba(0,0,0,0.35)',
          fontWeight: '300',
        };
        
        return React.createElement('span', {
          style: {
            fontFamily: "'Montserrat', sans-serif",
            fontSize: 'clamp(2.5rem, 12vw, 4.5rem)',
            fontWeight: '400',
            letterSpacing: '0.02em',
            display: 'flex',
            alignItems: 'baseline',
            justifyContent: 'center',
          }
        }, [
          // Leading punctuation (dimmed, slightly smaller)
          leadingPunct && React.createElement('span', {
            key: 'leading',
            style: { ...punctStyle, fontSize: '0.75em', marginRight: '0.05em' }
          }, leadingPunct),
          
          // Core word with ORP highlighting
          React.createElement('span', { key: 'core' }, 
            coreWord.split('').map((char, idx) => 
              React.createElement('span', {
                key: idx,
                style: {
                  color: idx === orpPos ? '#ef4444' : (darkMode ? '#ffffff' : '#1a1a1a'),
                  fontWeight: idx === orpPos ? '500' : '400',
                }
              }, char)
            )
          ),
          
          // Trailing punctuation (dimmed, slightly smaller)
          trailingPunct && React.createElement('span', {
            key: 'trailing',
            style: { ...punctStyle, fontSize: '0.85em', marginLeft: '0.02em' }
          }, trailingPunct),
        ]);
      };

      // ============================================================
      // Chapter splash screen component
      // ============================================================
      const renderChapterSplash = () => {
        if (!showChapterSplash || !book) return null;
        
        const chapter = book.chapters[chapterIndex];
        if (!chapter) return null;
        
        return React.createElement('div', {
          key: 'splash',
          className: `chapter-splash ${splashFading ? 'fading' : ''}`,
          style: {
            position: 'fixed',
            inset: 0,
            zIndex: 100,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: darkMode ? 'rgba(10, 10, 10, 0.95)' : 'rgba(250, 250, 250, 0.95)',
            backdropFilter: 'blur(8px)',
          }
        }, [
          // Chapter number
          React.createElement('div', {
            key: 'number',
            style: {
              fontSize: '0.875rem',
              fontWeight: '500',
              textTransform: 'uppercase',
              letterSpacing: '0.15em',
              color: '#ef4444',
              marginBottom: '1rem',
            }
          }, `Chapter ${chapterIndex + 1} of ${book.chapters.length}`),
          
          // Chapter title
          React.createElement('div', {
            key: 'title',
            style: {
              fontSize: 'clamp(1.5rem, 6vw, 2.5rem)',
              fontWeight: '600',
              textAlign: 'center',
              padding: '0 2rem',
              color: darkMode ? '#ffffff' : '#1a1a1a',
              maxWidth: '600px',
              lineHeight: '1.3',
            }
          }, chapter.title),
          
          // Subtitle
          React.createElement('div', {
            key: 'subtitle',
            style: {
              marginTop: '1.5rem',
              fontSize: '0.875rem',
              color: darkMode ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)',
            }
          }, pendingPlay ? 'Starting in a moment...' : 'Tap Play to begin'),
        ]);
      };

      // ============================================================
      // Dialogue indicator component
      // ============================================================
      const renderDialogueIndicator = () => {
        if (!inDialogue || showChapterSplash) return null;
        
        return React.createElement('div', {
          key: 'dialogue-indicator',
          style: {
            position: 'absolute',
            top: '1rem',
            left: '50%',
            transform: 'translateX(-50%)',
            display: 'flex',
            alignItems: 'center',
            gap: '0.5rem',
            padding: '0.375rem 0.75rem',
            borderRadius: '999px',
            backgroundColor: darkMode ? 'rgba(239, 68, 68, 0.15)' : 'rgba(239, 68, 68, 0.1)',
            border: `1px solid ${darkMode ? 'rgba(239, 68, 68, 0.3)' : 'rgba(239, 68, 68, 0.2)'}`,
            animation: 'subtlePulse 3s ease-in-out infinite',
          }
        }, [
          React.createElement('span', {
            key: 'icon',
            style: { fontSize: '0.875rem', opacity: 0.8 }
          }, '"'),
          React.createElement('span', {
            key: 'text',
            style: {
              fontSize: '0.6875rem',
              fontWeight: '500',
              textTransform: 'uppercase',
              letterSpacing: '0.05em',
              color: darkMode ? 'rgba(239, 68, 68, 0.9)' : 'rgba(239, 68, 68, 0.8)',
            }
          }, 'Dialogue'),
        ]);
      };

      // ============================================================
      // Navigation feedback indicator (+1, +2, etc)
      // ============================================================
      const renderNavFeedback = () => {
        if (!navFeedback) return null;
        
        const isBack = navFeedback.direction === 'back';
        const arrow = isBack ? 'â†' : 'â†’';
        const sign = isBack ? '-' : '+';
        
        return React.createElement('div', {
          key: 'nav-feedback-' + navFeedback.count + navFeedback.direction,
          style: {
            position: 'absolute',
            bottom: focusMode ? '5rem' : '1rem',
            left: '50%',
            transform: 'translateX(-50%)',
            display: 'flex',
            alignItems: 'center',
            gap: '0.5rem',
            padding: '0.5rem 1rem',
            borderRadius: '999px',
            backgroundColor: darkMode ? 'rgba(255, 255, 255, 0.15)' : 'rgba(0, 0, 0, 0.1)',
            border: `1px solid ${darkMode ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.15)'}`,
            animation: isBack ? 'navFeedbackSlideRight 0.2s ease-out' : 'navFeedbackSlideLeft 0.2s ease-out',
            pointerEvents: 'none',
          }
        }, [
          React.createElement('span', {
            key: 'arrow',
            style: { 
              fontSize: '1.25rem', 
              fontWeight: '600',
              color: darkMode ? '#ffffff' : '#1a1a1a',
            }
          }, arrow),
          React.createElement('span', {
            key: 'count',
            style: {
              fontSize: '1.125rem',
              fontWeight: '700',
              color: '#ef4444',
            }
          }, sign + navFeedback.count),
        ]);
      };

      // ============================================================
      // Focus mode exit button (for mobile)
      // ============================================================
      const renderFocusModeExit = () => {
        if (!focusMode) return null;
        
        return React.createElement('button', {
          key: 'focus-exit',
          onClick: (e) => {
            e.stopPropagation();
            setFocusMode(false);
          },
          style: {
            position: 'absolute',
            top: '1rem',
            right: '1rem',
            width: '44px',
            height: '44px',
            borderRadius: '50%',
            backgroundColor: darkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
            border: `1px solid ${darkMode ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.15)'}`,
            color: darkMode ? 'rgba(255, 255, 255, 0.6)' : 'rgba(0, 0, 0, 0.5)',
            fontSize: '1.25rem',
            fontWeight: '300',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 210,
          }
        }, 'âœ•');
      };

      // ============================================================
      // Calculate progress stats (excluding paragraph markers)
      // ============================================================
      const actualWords = words.filter(w => w !== PARAGRAPH_MARKER);
      const actualCurrentIndex = words.slice(0, currentIndex + 1).filter(w => w !== PARAGRAPH_MARKER).length - 1;
      const progress = actualWords.length > 0 ? ((Math.max(0, actualCurrentIndex) + 1) / actualWords.length) * 100 : 0;
      const wordsRemaining = actualWords.length - actualCurrentIndex - 1;
      const timeRemaining = wordsRemaining > 0 ? Math.ceil(wordsRemaining / wpm) : 0;
      const currentSentenceNum = getCurrentSentence() + 1;

      // ============================================================
      // Theme configuration
      // ============================================================
      const theme = {
        bg: darkMode ? '#0a0a0a' : '#fafafa',
        card: darkMode ? 'rgba(255,255,255,0.04)' : 'rgba(0,0,0,0.03)',
        cardBorder: darkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.08)',
        text: darkMode ? '#ffffff' : '#1a1a1a',
        muted: darkMode ? 'rgba(255,255,255,0.45)' : 'rgba(0,0,0,0.45)',
        accent: '#ef4444',
        button: darkMode ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.06)',
        buttonBorder: darkMode ? 'rgba(255,255,255,0.12)' : 'rgba(0,0,0,0.12)',
        dropZone: darkMode ? 'rgba(239,68,68,0.1)' : 'rgba(239,68,68,0.08)',
      };

      const buttonStyle = {
        backgroundColor: theme.button,
        color: theme.text,
        border: `1px solid ${theme.buttonBorder}`,
        borderRadius: '10px',
        padding: '12px 20px',
        fontSize: '14px',
        fontWeight: '500',
        fontFamily: "'Inter', system-ui, sans-serif",
        cursor: 'pointer',
        transition: 'all 0.15s ease',
      };

      // ============================================================
      // Main render
      // ============================================================
      return React.createElement('div', {
        style: {
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          backgroundColor: theme.bg,
          color: theme.text,
          fontFamily: "'Inter', system-ui, sans-serif",
        },
        onDragOver: handleDragOver,
        onDragLeave: handleDragLeave,
        onDrop: handleDrop,
      }, [
        // Chapter splash overlay
        renderChapterSplash(),
        
        // Drop overlay
        isDragging && React.createElement('div', {
          key: 'drop',
          style: {
            position: 'fixed',
            inset: 0,
            zIndex: 50,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: theme.dropZone,
            backdropFilter: 'blur(4px)',
          }
        }, React.createElement('div', { style: { textAlign: 'center' } }, [
          React.createElement('div', { key: 'icon', style: { fontSize: '4rem', marginBottom: '1rem' } }, 'ðŸ“–'),
          React.createElement('div', { key: 'text', style: { fontSize: '1.25rem', fontWeight: '500' } }, 'Drop EPUB to load'),
        ])),

        // Loading overlay
        isLoading && React.createElement('div', {
          key: 'loading',
          style: {
            position: 'fixed',
            inset: 0,
            zIndex: 50,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            backgroundColor: 'rgba(0,0,0,0.85)',
          }
        }, React.createElement('div', { style: { textAlign: 'center' } }, [
          React.createElement('div', { key: 'title', style: { fontSize: '1.5rem', marginBottom: '0.5rem' } }, 'Loading...'),
          React.createElement('div', { key: 'sub', style: { color: theme.muted } }, 'Parsing EPUB'),
        ])),

        // Header (hidden in focus mode)
        !focusMode && React.createElement('div', {
          key: 'header',
          style: { padding: '1rem 1.25rem 0.75rem' }
        }, [
          // Book info
          book && React.createElement('div', {
            key: 'bookinfo',
            style: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '0.75rem' }
          }, [
            React.createElement('div', { key: 'left', style: { flex: 1, minWidth: 0, marginRight: '0.75rem' } }, [
              React.createElement('div', {
                key: 'title',
                style: { fontSize: '0.875rem', fontWeight: '500', color: theme.text, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }
              }, book.title),
              book.chapters.length > 1 && React.createElement('select', {
                key: 'chapters',
                value: chapterIndex,
                onChange: (e) => handleChapterChange(Number(e.target.value)),
                style: {
                  marginTop: '0.25rem',
                  fontSize: '0.75rem',
                  backgroundColor: 'transparent',
                  border: 'none',
                  outline: 'none',
                  cursor: 'pointer',
                  color: theme.muted,
                  maxWidth: '200px',
                }
              }, book.chapters.map((ch, idx) =>
                React.createElement('option', {
                  key: ch.id,
                  value: idx,
                  style: { backgroundColor: theme.bg, color: theme.text }
                }, ch.title)
              )),
            ]),
            React.createElement('button', {
              key: 'close',
              onClick: handleCloseBook,
              style: { fontSize: '0.75rem', padding: '0.25rem 0.75rem', borderRadius: '4px', backgroundColor: theme.button, color: theme.muted, border: 'none', cursor: 'pointer' }
            }, 'Close'),
          ]),

          // Progress info
          React.createElement('div', {
            key: 'progressinfo',
            style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem', color: theme.muted }
          }, [
            React.createElement('span', { key: 'left', style: { fontSize: '0.75rem', fontWeight: '500' } },
              `${book ? `Ch ${chapterIndex + 1}/${book.chapters.length}` : 'Demo'} Â· Sent ${currentSentenceNum}/${sentences.length}`
            ),
            React.createElement('span', { key: 'right', style: { fontSize: '0.75rem', fontWeight: '500' } },
              timeRemaining > 0 ? `${timeRemaining}m left` : 'Done'
            ),
          ]),

          // Progress bar
          React.createElement('div', {
            key: 'progressbar',
            style: { height: '4px', borderRadius: '2px', overflow: 'hidden', backgroundColor: theme.cardBorder }
          }, React.createElement('div', {
            style: { height: '100%', width: `${progress}%`, backgroundColor: theme.accent, transition: 'width 0.2s ease-out' }
          })),
        ]),

        // Word display area (with tap zones for mobile)
        React.createElement('div', {
          key: 'display',
          onClick: handleTapZone,
          style: {
            flex: 1,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            padding: focusMode ? '0' : '1rem',
            minHeight: focusMode ? '100vh' : '220px',
            position: focusMode ? 'fixed' : 'relative',
            inset: focusMode ? 0 : 'auto',
            zIndex: focusMode ? 200 : 'auto',
            backgroundColor: focusMode ? (darkMode ? '#000000' : '#ffffff') : 'transparent',
            cursor: 'pointer',
          }
        }, [
          // Dialogue indicator (hidden in focus mode)
          !focusMode && renderDialogueIndicator(),
          
          // Navigation feedback indicator
          renderNavFeedback(),
          
          // Focus mode exit button (for mobile)
          renderFocusModeExit(),
          
          // Focus mode exit hint
          focusMode && React.createElement('div', {
            key: 'focus-hint',
            style: {
              position: 'absolute',
              bottom: '2rem',
              left: '50%',
              transform: 'translateX(-50%)',
              fontSize: '0.75rem',
              color: darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.2)',
              textAlign: 'center',
            }
          }, 'Tap âœ• or press Esc to exit Â· Tap: â† center â†’ '),
          
          // Main content
          showTextInput
            ? React.createElement('div', { key: 'input', style: { width: '100%', maxWidth: '32rem' } },
                React.createElement('textarea', {
                  value: inputText,
                  onChange: (e) => setInputText(e.target.value),
                  autoFocus: true,
                  placeholder: 'Paste your text here...',
                  style: {
                    width: '100%',
                    height: '14rem',
                    padding: '1rem',
                    borderRadius: '0.75rem',
                    fontSize: '0.9375rem',
                    lineHeight: '1.6',
                    resize: 'none',
                    backgroundColor: theme.card,
                    color: theme.text,
                    border: `1px solid ${theme.cardBorder}`,
                    outline: 'none',
                  }
                })
              )
            : loadError
              ? React.createElement('div', { key: 'error', style: { textAlign: 'center', padding: '1.5rem' } }, [
                  React.createElement('div', { key: 'err', style: { color: '#f87171', marginBottom: '0.5rem' } }, `âš ï¸ ${loadError}`),
                  React.createElement('button', {
                    key: 'dismiss',
                    onClick: () => setLoadError(null),
                    style: { fontSize: '0.875rem', textDecoration: 'underline', color: theme.muted, background: 'none', border: 'none', cursor: 'pointer' }
                  }, 'Dismiss'),
                ])
              : React.createElement('div', { key: 'word' }, renderWord())
        ]),

        // Controls (hidden in focus mode)
        !focusMode && React.createElement('div', {
          key: 'controls',
          style: { padding: '0 1rem 1.25rem' }
        }, React.createElement('div', {
          style: {
            maxWidth: '28rem',
            margin: '0 auto',
            padding: '1rem',
            borderRadius: '1rem',
            backgroundColor: theme.card,
            border: `1px solid ${theme.cardBorder}`,
          }
        }, [
          // Play/Reset
          React.createElement('div', {
            key: 'playrow',
            style: { display: 'flex', justifyContent: 'center', gap: '0.75rem', marginBottom: '0.75rem' }
          }, [
            React.createElement('button', {
              key: 'play',
              onClick: handlePlayPause,
              disabled: showChapterSplash,
              style: {
                ...buttonStyle,
                backgroundColor: isPlaying ? 'transparent' : theme.accent,
                color: isPlaying ? theme.accent : '#ffffff',
                border: isPlaying ? `2px solid ${theme.accent}` : 'none',
                padding: '12px 28px',
                fontWeight: '600',
                opacity: showChapterSplash ? 0.5 : 1,
              }
            }, isPlaying ? 'Pause' : 'Play'),
            React.createElement('button', { key: 'reset', onClick: handleReset, style: buttonStyle }, 'Reset'),
          ]),

          // Sentence nav
          React.createElement('div', {
            key: 'navrow',
            style: { display: 'flex', justifyContent: 'center', gap: '0.75rem', marginBottom: '0.75rem' }
          }, [
            React.createElement('button', { key: 'prev', onClick: handleBackSentence, style: buttonStyle }, 'â† Prev'),
            React.createElement('button', { key: 'next', onClick: handleForwardSentence, style: buttonStyle }, 'Next â†’'),
          ]),

          // Settings
          React.createElement('div', {
            key: 'settings',
            style: { display: 'flex', justifyContent: 'center', gap: '0.5rem', marginBottom: '1rem', flexWrap: 'wrap' }
          }, [
            React.createElement('button', {
              key: 'open',
              onClick: () => fileInputRef.current?.click(),
              style: { ...buttonStyle, padding: '10px 14px', fontSize: '13px' }
            }, 'ðŸ“ Open'),
            React.createElement('button', {
              key: 'paste',
              onClick: handleSetText,
              style: { ...buttonStyle, padding: '10px 14px', fontSize: '13px' }
            }, showTextInput ? 'âœ“ Save' : 'ðŸ“ Paste'),
            React.createElement('button', {
              key: 'theme',
              onClick: () => setDarkMode(!darkMode),
              style: { ...buttonStyle, padding: '10px 14px', fontSize: '13px' }
            }, darkMode ? 'â˜€ï¸' : 'ðŸŒ™'),
            React.createElement('button', {
              key: 'pauses',
              onClick: () => setPausesEnabled(!pausesEnabled),
              style: { ...buttonStyle, padding: '10px 14px', fontSize: '13px', opacity: pausesEnabled ? 1 : 0.5 }
            }, pausesEnabled ? 'â¸ On' : 'â¸ Off'),
            React.createElement('button', {
              key: 'focus',
              onClick: () => setFocusMode(true),
              style: { ...buttonStyle, padding: '10px 14px', fontSize: '13px' }
            }, 'â›¶ Focus'),
          ]),

          // WPM
          React.createElement('div', {
            key: 'wpm',
            style: { display: 'flex', alignItems: 'center', gap: '1rem' }
          }, [
            React.createElement('div', {
              key: 'wpmlabel',
              style: { textAlign: 'center', minWidth: '50px' }
            }, [
              React.createElement('div', { key: 'val', style: { fontSize: '1.5rem', fontWeight: '700', color: theme.text } }, wpm),
              React.createElement('div', { key: 'label', style: { fontSize: '0.7rem', textTransform: 'uppercase', letterSpacing: '0.05em', color: theme.muted } }, 'WPM'),
            ]),
            React.createElement('input', {
              key: 'slider',
              type: 'range',
              min: 100,
              max: 1000,
              step: 25,
              value: wpm,
              onChange: (e) => setWpm(Number(e.target.value)),
              style: { flex: 1, height: '4px', borderRadius: '2px', backgroundColor: theme.cardBorder, cursor: 'pointer' }
            }),
          ]),
        ])),

        // Hidden file input
        React.createElement('input', {
          key: 'fileinput',
          ref: fileInputRef,
          type: 'file',
          accept: '.epub',
          onChange: handleFileSelect,
          style: { display: 'none' }
        }),
      ]);
    }

    // Mount app with error handling
    try {
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(SpeedReader));
    } catch (err) {
      document.getElementById('root').innerHTML = '<div style="color: #ef4444; padding: 2rem; text-align: center;"><h2>Error loading app</h2><p>' + err.message + '</p></div>';
      console.error('Mount error:', err);
    }

    // Global error handler for uncaught errors
    window.onerror = function(msg, url, line, col, error) {
      console.error('Global error:', msg, 'at', line + ':' + col);
      const root = document.getElementById('root');
      if (root && !root.innerHTML.trim()) {
        root.innerHTML = '<div style="color: #ef4444; padding: 2rem; text-align: center;"><h2>Error</h2><p>' + msg + '</p></div>';
      }
    };

    // Register service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(() => {});
    }
  </script>
</body>
</html>
